{"version":3,"sources":["helpers/fetchAction.ts","features/cryptos/cryptosSlice.ts","features/crypto-prices/cryptoPricesSlice.ts","components/Loading.tsx","App.tsx","store.ts","index.tsx"],"names":["fetchAction","url","a","dispatch","getData","setFetchData","options","data","undefined","error","isLoading","fetch","response","json","message","cryptosSlice","createSlice","initialState","name","reducers","setCryptos","state","payload","Object","assign","cryptosReducer","reducer","actions","fetchCryptos","getState","cryptos","filter","is_active","map","cmcRank","priceUSD","symbol","sort","b","localeCompare","selectCryptos","cryptoPricesSlice","addedCryptos","addCryptos","crypto","some","push","removeCrypto","index","findIndex","splice","cryptoPricesReducer","selectAddedCryptos","cryptoPrices","Loading","Style","createGlobalStyle","CryptoPrices","lazy","App","fallback","store","configureStore","render","document","getElementById"],"mappings":"iRAmDeA,EA1CE,uCAAG,WAClBC,EADkB,8BAAAC,EAAA,6DAGhBC,EAHgB,EAGhBA,SACAC,EAJgB,EAIhBA,QACAC,EALgB,EAKhBA,aACGC,EANa,qDAalBH,EACEE,EAAa,CACXE,UAAMC,EACNC,WAAOD,EACPE,WAAW,KAjBG,kBAsBOC,MAAMV,EAAKK,GAtBlB,cAsBVM,EAtBU,gBAuBaA,EAASC,OAvBtB,OAuBVA,EAvBU,OAwBhBN,GAAO,OAACH,QAAD,IAACA,IAAY,SAACS,GAAD,OAAoBA,IAAOA,GAxB/B,yDA0BhBV,EACEE,EAAa,CACXI,MAAO,KAAMK,QACbJ,WAAW,KA7BC,2BAkClBP,EACEE,EAAa,CACXE,OACAG,WAAW,KArCG,0DAAH,wDCCJK,EAAeC,YAAY,CACtCC,aAH0B,GAI1BC,KAAM,UACNC,SAAU,CACRC,WAAY,SAACC,EAAD,GAA+C,IAArCC,EAAoC,EAApCA,QACpBC,OAAOC,OAAOH,EAAOC,OAKdG,EAAiBV,EAAaW,QAE5BN,EAAeL,EAAaY,QAA5BP,WAEFQ,EAAe,kBAAgB,SAACzB,EAAU0B,GACrD,IAAIA,IAAWC,QAAQpB,UASvB,OAAOV,EACL,+CACA,CACEG,WACAC,QAAS,qBAAGG,KAEPwB,QAAO,qBAAGC,aACVC,KAAI,kBAAiB,CACpBC,QAAS,EACTC,SAAU,EACVC,OAHG,EAAGA,WAKPC,MAAK,kBAAYnC,EAAZ,EAAGgC,QAAH,SAAmBA,QAAqBhC,KAC7CmC,MAAK,kBAAWnC,EAAX,EAAGkC,OAAuBE,EAA1B,EAAkBF,OAAlB,OAAkClC,EAAEqC,cAAcD,OAC5DjC,aAAce,MAKPoB,EAAgB,SAAC,GAAD,SAAGV,U,2LCxCnBW,EAAoBzB,YAAY,CAC3CC,aAL0B,CAC1ByB,aAAc,IAKdxB,KAAM,eACNC,SAAU,CACRwB,WAAY,SAACtB,EAAD,GAAkD,IAAD,EAAvCC,EAAuC,EAAvCA,QAAuC,cACtCA,GADsC,yBAChDsB,EADgD,QAGtDvB,EAAMqB,aAAaG,MAAK,qBAAGT,SAAwBQ,EAAOR,WAE3Df,EAAMqB,aAAaI,KAAKF,IAJ5B,2BAA+B,IAD4B,gCAU7DG,aAAc,SAAC1B,EAAD,GAA0D,IAAhDC,EAA+C,EAA/CA,QAChB0B,EAAQ3B,EAAMqB,aAAaO,WAC/B,qBAAGb,SAAwBd,MAEd,IAAX0B,GACF3B,EAAMqB,aAAaQ,OAAOF,EAAO,OAM5BG,EAAsBV,EAAkBf,Q,EAETe,EAAkBd,QAA/CgB,E,EAAAA,WAAYI,E,EAAAA,aAEdK,EAAqB,SAAC,GAAD,SAAGC,aACtBX,e,gDCvCAY,IAFC,kBAAM,6C,wWCGtB,IAAMC,EAAQC,YAAH,KAQLC,EAAeC,gBAAK,kBAAM,sDAYjBC,EAVH,kBACV,qCACE,cAACJ,EAAD,IACA,+CACA,cAAC,WAAD,CAAUK,SAAU,cAACN,EAAA,EAAD,IAApB,SACE,cAACG,EAAD,U,uBCfOI,EAAQC,YAAe,CAClCpC,QAAS,CACP2B,aAAcF,IACdrB,QAASL,OCDbsC,iBACE,cAAC,IAAD,CAAUF,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFG,SAASC,eAAe,W","file":"static/js/main.ac4bf637.chunk.js","sourcesContent":["import { Dispatch } from \"redux\";\nimport { PayloadAction, PayloadActionCreator } from \"@reduxjs/toolkit\";\n\nexport interface FetchData<T> {\n  data?: T;\n  error?: string;\n  isLoading?: boolean;\n}\n\nconst fetchAction = async <Response, T>(\n  url: Parameters<typeof fetch>[0],\n  {\n    dispatch,\n    getData,\n    setFetchData,\n    ...options\n  }: Parameters<typeof fetch>[1] & {\n    dispatch: Dispatch<PayloadAction<FetchData<T>>>;\n    getData: (json: Response) => T;\n    setFetchData: PayloadActionCreator<FetchData<T>>;\n  }\n) => {\n  dispatch(\n    setFetchData({\n      data: undefined,\n      error: undefined,\n      isLoading: true,\n    })\n  );\n  let data;\n  try {\n    const response = await fetch(url, options);\n    const json: Response = await response.json();\n    data = (getData ?? ((json: Response) => json))(json);\n  } catch (error) {\n    dispatch(\n      setFetchData({\n        error: error.message,\n        isLoading: false,\n      })\n    );\n    return;\n  }\n  dispatch(\n    setFetchData({\n      data,\n      isLoading: false,\n    })\n  );\n};\n\nexport default fetchAction;\n","import { PayloadAction, createSlice } from \"@reduxjs/toolkit\";\n\nimport Crypto from \"./Crypto\";\nimport fetchAction, { FetchData } from \"helpers/fetchAction\";\nimport { AppThunk, RootState } from \"store\";\n\ninterface State extends FetchData<Crypto[]> {}\n\nconst initialState: State = {};\n\nexport const cryptosSlice = createSlice({\n  initialState,\n  name: \"cryptos\",\n  reducers: {\n    setCryptos: (state, { payload }: PayloadAction<State>) => {\n      Object.assign(state, payload);\n    },\n  },\n});\n\nexport const cryptosReducer = cryptosSlice.reducer;\n\nexport const { setCryptos } = cryptosSlice.actions;\n\nexport const fetchCryptos = (): AppThunk => (dispatch, getState) => {\n  if (getState().cryptos.isLoading) {\n    return;\n  }\n  interface CoinMarketCapMapResponse {\n    data: {\n      is_active: boolean;\n      symbol: string;\n    }[];\n  }\n  return fetchAction<CoinMarketCapMapResponse, State[\"data\"]>(\n    \"https://www.stackadapt.com/coinmarketcap/map\",\n    {\n      dispatch,\n      getData: ({ data }) =>\n        data\n          .filter(({ is_active: isActive }) => isActive)\n          .map(({ symbol }) => ({\n            cmcRank: 0,\n            priceUSD: 0,\n            symbol,\n          }))\n          .sort(({ cmcRank: a }, { cmcRank: b }) => b - a)\n          .sort(({ symbol: a }, { symbol: b }) => a.localeCompare(b)),\n      setFetchData: setCryptos,\n    }\n  );\n};\n\nexport const selectCryptos = ({ cryptos }: RootState) => cryptos;\n\nexport default cryptosSlice;\n","import { PayloadAction, createSlice } from \"@reduxjs/toolkit\";\n\nimport Crypto from \"features/cryptos/Crypto\";\nimport { RootState } from \"store\";\n\ninterface State {\n  addedCryptos: Crypto[];\n}\n\nconst initialState: State = {\n  addedCryptos: [],\n};\n\nexport const cryptoPricesSlice = createSlice({\n  initialState,\n  name: \"cryptoPrices\",\n  reducers: {\n    addCryptos: (state, { payload }: PayloadAction<Crypto[]>) => {\n      for (const crypto of payload) {\n        if (\n          !state.addedCryptos.some(({ symbol }) => symbol === crypto.symbol)\n        ) {\n          state.addedCryptos.push(crypto);\n        }\n      }\n    },\n\n    removeCrypto: (state, { payload }: PayloadAction<Crypto[\"symbol\"]>) => {\n      const index = state.addedCryptos.findIndex(\n        ({ symbol }) => symbol === payload\n      );\n      if (index !== -1) {\n        state.addedCryptos.splice(index, 1);\n      }\n    },\n  },\n});\n\nexport const cryptoPricesReducer = cryptoPricesSlice.reducer;\n\nexport const { addCryptos, removeCrypto } = cryptoPricesSlice.actions;\n\nexport const selectAddedCryptos = ({ cryptoPrices }: RootState) =>\n  cryptoPrices.addedCryptos;\n\nexport default cryptoPricesSlice;\n","import React from \"react\";\n\nconst Loading = () => <p>Loading...</p>;\n\nexport default Loading;\n","import React, { Suspense, lazy } from \"react\";\nimport { createGlobalStyle } from \"styled-components\";\n\nimport Loading from \"components/Loading\";\n\nconst Style = createGlobalStyle`\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\n    Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  margin: 1.5em;\n}\n`;\n\nconst CryptoPrices = lazy(() => import(\"features/crypto-prices/CryptoPrices\"));\n\nconst App = () => (\n  <>\n    <Style />\n    <h1>Crypto Prices</h1>\n    <Suspense fallback={<Loading />}>\n      <CryptoPrices />\n    </Suspense>\n  </>\n);\n\nexport default App;\n","import { Action, ThunkAction, configureStore } from \"@reduxjs/toolkit\";\n\nimport { cryptoPricesReducer } from \"features/crypto-prices/cryptoPricesSlice\";\nimport { cryptosReducer } from \"features/cryptos/cryptosSlice\";\n\nexport const store = configureStore({\n  reducer: {\n    cryptoPrices: cryptoPricesReducer,\n    cryptos: cryptosReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\n\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","import React from \"react\";\nimport { Provider } from \"react-redux\";\nimport { render } from \"react-dom\";\n\nimport App from \"App\";\nimport { store } from \"store\";\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}